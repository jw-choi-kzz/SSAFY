## 상속 Inheritance
어떤 클래스의 특성을 그대로 갖는 새로운 클래스를 정의  
확장성, 재사용성 : 부모의 생성자와 초기화 블록은 상속 x  
클래스 선언 시 extends 키워드 명시 : 자바는 다중 상속 허용x, 단일 상속 지원  
관계) 부모_상위_Super 클래스 <-> 자식_하위_Sub 클래스  
자식클래스는 부모 클래스의 멤버변수, 메서드를 자신의 것처럼 사용 가능  
Object 클래스는 모든 클래스의 조상  
super 키워드 : 조상클래스의 생성자 호출  
```java
public Student(String name, int age, String major){
  super(name, age);
  this.major = major;
}
```
**오버라이딩 재정의 overriding** : 상위클래스에서 선언된 메서드를 자식 클래스에서 재정의  
메서드명, 반환형, 매개변수(타입, 개수, 순서) 동일해야 함, 하위 클래스의 접근제어자 범위 >= 상위 클래스, 조상보다 더 큰 예외 던질 수 없음  
  
### Object
toString, equals 메서드 *(참조자료형은 ==로 객체 주소 값을 비교)*  
_문자열은 String 클래스에 이미 equals가 overriding_  
#### hashCode  
객체의 해시코드 : 시스템에서 객체를 구별하기 위해 사용되는 정수값  
HashSet, HashMap 등에서 객체 동일성 확인 위해 사용  
equals 메서드 overriding 할때 반드시 hashCode도 overriding 할 것(미리 작성된 String이나 Number 등에서 재정의된 hashCode 활용 권장)  
  
### final
해당 선언이 최종 상태(수정 불가, 클래스면 상속 불가, 메서드면 재정의 불가, 변수면 값 변경 불가)  
  
-----------------------------
  
## 다형성 Polymorphism
상속 관계에서 멤버변수가 중복되면 참조변수 타입에 따라 연결, 접근범위가 달라짐  
(자손타입->조상타입: 묵시적 형 변환. 형변환 생략 가능)  
(조상타입->자손타입: 명시적 형 변환. 형변환 생략 불가)  
메서드가 중복될 때 무조건 자식 클래스의 메서드(가장 마지막에 작성된 것) 호출 = **동적 바인딩**  
static 메서드는 참조변수 타입의 영향을 받기 때문에 **클래스 이름**으로 메서드 호출   
활용) 다른 타입의 객체를 다루는 배열 ```Person [] persons = new Person(); 하고 instanceof를 통해 어떤 타입인지 확인```   
  
### 추상클래스 abstract class
자손 클래스에서 **반드시 재정의**하기 때문에 조상클래스에서는 메서드의 선언부만 남김->자식클래스는 **의무적으로 구현**해야 함  
_(미완성이라)_ **객체를 생성할 수 없는** 클래스이므로 클래스 선언부에 abstract 추가, 구현부가 없으므로 메서드 선언부에 abstract 추가  
특징) abstract 클래스는 상속 전용 클래스, 상위 클래스 타입으로 자식 참조 가능  
사용 목적) 구현의 강제를 ㅌ오해 프로그램의 안정성 향상  
+) **익명 클래스**  
```java
Chef c2 = new Chef(){
  //여기서 1회 한정으로 구현하고 인스턴스를 만들 수 있게 도와줄수도
  @Override
  public void cook {
    System.out.println("어어");
  }
}
```
방법) 필드에 익명 자식 객체를 생성, 로컬 변수의 초기값으로 대입, 익명객체 매개변수로 대입  
  
------------------
  
## 인터페이스
완벽히 추상화된 설계도. 클래스와 유사하게 작성 가능. 모든 메서드가 추상메서드  
그 자체로 인스턴스 생성할 수 없음(구현부x) -> implements 키워드로 구현클래스 작성. 추상 메서드를 반드시 overriding  
(public) **default** method : 인터페이스에 구현부가 있는 메서드를 작성할 수 있음, 접근제한자는 public  
필요성) **표준화** 처리, 개발시간 단축, 서로 관계 없는 클래스들이 관계를 맺도록, 손쉬운 모듈 교체 지원, 독립적 프로그래밍 가능  
  
----------------------
  
## Generic
다양한 종류의 객체들을 다루는 메서드나 컬렉션 클래스에서 컴파일 시 타입을 체크해주는 기능  
객체의 타입 안정성을 제공, 형변환의 번거로움이 없어 코드 간결  
선언) ```public class ClassName<T> {} //선언 시 <>에 타입 파라미터 표시  
**타입 파라미터** : 임의의 참조형 타입. T(reference type), E(element), K(key), V(value)  
객체 생성) 변수와 생성 쪽 타입은 반드시 일치(상속관계여도), 추정 가능하면 생성자쪽 타입 생략 가능, 지정안하면 자동으로 T(Object)  
  
#### 제한된 제네릭 클래스  
**구체적인 타입 제한** 필요할 때 **extends** 키워드 사용, 클래스와 함께 인터페이스 제약 조건을 이용할 경우 &로 연결  
```class Box <T extends Person> { ... }```  
#### 와일드카드 이용
generic type에서 구체적인 타입 대신 사용  
```Generic type<?>``` : 타입에 제한 없음  
```Generic type<? extends T>``` : T와 T를 상속받은 타입들만 사용 가능  
```Generic type<? super T>``` : T와 T의 조상 타입만 사용 가능  
