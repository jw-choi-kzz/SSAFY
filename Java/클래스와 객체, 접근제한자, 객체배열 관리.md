## 객체지향 프로그래밍 Object Oriented Programming  
특징) 추상화, 다형성, 상속, 캡슐화  
장점) 모듈화된 프로그래밍, 재사용성이 높음  
객체지향 설계 SOLID) 단일 책임 원칙, 개방-폐쇠 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존관계 역적 원칙  
  
## 클래스
**클래스** : 객체를 만드는 설계도  
관련 있는 변수와 함수를 묶어서 만든 사용자 정의 자료형  
각 객체들이 어떤 특징(속성과 동작)을 가지고 있을지 결정  
**인스턴스** : 클래스를 통해 생성된 객체  
  
구성) 속성 Attribute **필드** _멤버변수_ / 동작 Behavior **메서드** / 생성자 Constructor _객체 생성을 위해_ / 중첩 클래스(클래스 내부의 클래스) _inner class_  
  
**클래스 선언 및 객체 생성**  
```
[접근제한자] [활용제한자] class 클래스명 {
  속성 정의 (필드)
  기능 정의 (메서드)
  생성자
}
```
접근 시) ```클래스명 변수명 = new 클래스명();```  ```변수명.필드명```  ```변수명.메서드명();```  
  
### 변수
#### 클래스 변수 class variable
클래스 영역 선언 (static 키워드)   
생성 시기 : 클래스가 메모리에 올라 갔을 때  
모든 인스턴스가 공유함  
#### 인스턴스 변수 instance variable
클래스 영역 선언  
생성 시기 : 인스턴스가 생성되었을 때 (new)  
인스턴스별로 생성됨 _(인스턴스마다 관리)_  
#### 지역 변수 local variable
클래스 영역 이외 (메서드, 생성자 등)  
생성 시기 : 선언되었을 때
  
### 메서드
리턴 타입은 선언 시 지정하고 작성했다면 반드시 해당 타입의 값 리턴(타입은 하나만 적용 가능), 없다면 void  
#### 매개 변수 Parameter
메서드에서 사용하는 것  
생략 가능. 전달 시 묵시적 형 변환  
#### 인자 Argument
호출하는 쪽에서 전달하는 것  
#### 메서드 오버로딩 Overloading
이름이 같고 매개변수가 다른 메서드를 여러개 정의하는 것  
중복 코드에 대한 효율적인 관리 가능  
파라미터의 개수 또는 **순서, 타입**이 달라야 함(파라미터 이름만 다른 건 X)  
리턴 타입이 다른 것은 의미 X  

## 생성자
### 생성자 메서드
new 키워드와 함께 호출하여 객체 생성  
클래스명과 동일, 결과형 리턴값을 갖지 않음 _(매개변수는 쓸수도 있다)_  
객체가 생성될 때 반드시 하나의 생성자를 호출  
멤버필드의 초기화에 주로 사용  
하나의 클래스 내부에 생성자가 하나도 없으면 **자동적으로 default 생성자**가 있는 것으로 인지(매개변수X, 내용X)  
매개변수 개수가 다르거나 자료형이 다른 여러 개의 생성자 있을 수 있음 = **생성자 오버로딩**  
생성자의 첫번째 라인으로 **this() 생성자**를 사용하여 또 다른 생성자 하나 호출 가능  
#### default 생성자
클래스 내 생성자가 하나도 정의되어 있지 않을 경우 JVM이 자동으로 제공하는 생성자  
매개변수가 없는 형태 ```클래스명(){}```  
#### 파라미터가 있는 생성자
생성자의 목적이 필드 초기화  
생성자 호출 시 값을 넘겨주어야 함  
해당 생성자를 작성하면 JVM에서 기본 생성자를 추가하지 않음  
  
#### this
참조 변수로써 객체 자신을 가리킴, 자신의 멤버 접근 가능  
지역변수(매개변수)와 필드의 이름이 동일할 경우 필드임을 식별할 수 있게 함  
객체에 대한 참조이므로 static 영역에서 this 사용 불가  
  
활용)  
```this.멤버변수```  ```this ( [인자값..]) 생성자 호출```  
```java
public class Dog {
  String name;//필드의 이름
  public Dog(String name){//지역변수(매개변수)
    this.name = name;//this 지역변수(매개변수) = 필드의 이름
    //생성자 내에서 첫번째 구문에 위치해야 함 
  }
  Dog () {
    this ("쫑");//생성자 호출
  }
}
```
  
-------------------------------
  
## JVM 메모리 구조
Java 언어는 개발자가 아닌 Garbage Collection이 메모리 관리  
Class Loader(*.class 파일을 메모리로 읽어옴)  
**클래스 영역(메서드 영역)** : 클래스 정보 저장 영역  
**heap** : 인스턴스가 생성되는 공간  
**stack** : 메서드 수행 시 프레임 할당. 필요한 변수, 중간 결과 값 임시 기억하는 공간. 메서드 종료 시 할당 메모리 자동제거(LIFO _접시쌓기_)  
_new 뒤의 생성자()가 인스턴스를 생성하면 heap에 생성됨_  
```Person p1 = new Person();```
_stack의 main 함수 안에서 Person p1 : 주소 => 주소를 통해 heap에 접근 가능_  
  
### static
_'미리 쓸 수 있다'_  
로딩 시점) 클래스 로딩 시 (클래스 영역에 설정됨) _(non-static : 객체 생성 시, heap에 생성될 때)_  
메모리) 클래스당 하나의 메모리 공간만 할당(공유됨) _(non-static : 인스턴스 당 메모리 별도 할당)_  
static으로 선언된 pCount는 ```(인스턴스)p1.pCount``` 말고 ```(클래스)Person.pCount``` 이런 식으로 접근해라 = 클래스 영역에 생성되었기 때문에 인스턴스 생성 없이 접근할 수 있음(모든 인스턴스가 공유)  
  
static 영역에서는 non-static 영역 직접 접근 불가(아직 메모리에 없으니까), non-static 영역에서는 static 영역 접근 가능(이미 메모리에 있으니까)  
_(static은 **미리 메모리에 올라가 있기 때문에** 인스턴스 생성 여부와 관계 없음. non-static 영역은 인스턴스 만들어져야 접근 가능)_  
  
#### package
```com.ssafy.project_이름.module_이름```  
다른 패키지의 클래스 사용을 위해 import  
**캡슐화 Encapsulation** : 객체 속성(data fields)과 행위(methods)를 하나로 묶고 실제 구현 내용 일부를 외부에 감추어 은닉  
### 접근 제한자 access modifier
선언부에서 접근 허용 범위를 지정하는 역할의 키워드  
**public** : 모든 위치  
**protected** : 같은 패키지에서 접근이 가능, 다른 패키지의 클래스와 상속관계(extends) 있을 때만 접근 가능  
**(default)** : 같은 패키지에서만 접근 가능, 선언 없을 때 기본 적용  
**private** : 자신 클래스에서만 접근 가능  
접근을 위해 설정자 **setter** / 접근자 **getter** (set/get멤버변수명)  
  
### 싱글턴 패턴 Singleton Pattern
생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나, 이후 호출되는 생성자는 최초의 생성자가 생성한 객체 리턴  
```java
public class Manager {
  private static Manager manager = new Manager();
  private Manager () {}
  public static Manager getManager() {
    return manager;
  }
}
```
